The number of subsets for the set D = {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f} is 2^16 = 65536, so we can hash every transformation of S to its corresponding subset. For example, the value for 11 (0000000000001011) is the transformation of S by [0,1,3]. Note that for each transformation the order of the elimination does not matter.

To evaluate each transformation, Java native methods and string processing are too slow. You might need to do a custom one. I don't know if this is necessary in c++ but I doubt it.

Then think of a Hesse diagram (just for intuition, you don't need to actually code it) of the subsets of D and note that each permutation p corresponds to a path from {} to the set D in the diagram, and total(S,p) is the sum of all vertices in that graph. Then you can find maximum and minimum totals using DP. The code includes both bottom-up and top-down approaches. Finally to find the sum, you can use pure combinatorics, or make it a bit simpler with DP. The code includes both approaches also.